{
  "8-bit Counter": {
    "prefix": "counter8",
    "body": [
      "module counter_8bit(",
      "  input wire iCLK,",
      "  input wire iRSTn,",
      "  input wire iEN,",
      "  output reg [7:0] oCount",
      ");",
      "",
      "  always @(posedge iCLK or negedge iRSTn) begin",
      "    if (!iRSTn)",
      "      oCount<=8'd0;",
      "    else if (iEN)",
      "      oCount<=oCount + 1'b1;",
      "  end",
      "",
      "endmodule"
    ],
    "description": "8-bit counter with reset and enable"
  },
  "N-bit Counter": {
    "prefix": "countern",
    "body": [
      "module counter_${1:n}bit(",
      "  input wire iCLK,",
      "  input wire iRSTn,",
      "  input wire iEN,",
      "  output reg [${1:n}-1:0] oCount",
      ");",
      "",
      "  always @(posedge iCLK or negedge iRSTn) begin",
      "    if (!iRSTn)",
      "      oCount<={${1:n}}'d0;",
      "    else if (iEN)",
      "      oCount<=oCount + 1'b1;",
      "  end",
      "",
      "endmodule"
    ],
    "description": "N-bit parameterized counter"
  },
  "D Flip-Flop": {
    "prefix": "dff",
    "body": [
      "module d_ff(",
      "  input wire iCLK,",
      "  input wire iRSTn,",
      "  input wire iD,",
      "  output reg oQ",
      ");",
      "",
      "  always @(posedge iCLK or negedge iRSTn) begin",
      "    if (!iRSTn)",
      "      oQ<=1'b0;",
      "    else",
      "      oQ<=iD;",
      "  end",
      "",
      "endmodule"
    ],
    "description": "D Flip-Flop with asynchronous reset"
  },
  "T Flip-Flop": {
    "prefix": "tff",
    "body": [
      "module t_ff(",
      "  input wire iCLK,",
      "  input wire iRSTn,",
      "  input wire iT,",
      "  output reg oQ",
      ");",
      "",
      "  always @(posedge iCLK or negedge iRSTn) begin",
      "    if (!iRSTn)",
      "      oQ<=1'b0;",
      "    else if (iT)",
      "      oQ<=~oQ;",
      "  end",
      "",
      "endmodule"
    ],
    "description": "T Flip-Flop with asynchronous reset"
  },
  "Shift Register": {
    "prefix": "shiftreg",
    "body": [
      "module shift_register #(",
      "  parameter WIDTH = 8",
      ")(",
      "  input wire iCLK,",
      "  input wire iRSTn,",
      "  input wire iEN,",
      "  input wire iSI,",
      "  output wire oSO,",
      "  output reg [WIDTH-1:0] oData",
      ");",
      "",
      "  assign oSO = oData[WIDTH-1];",
      "",
      "  always @(posedge iCLK or negedge iRSTn) begin",
      "    if (!iRSTn)",
      "      oData<={WIDTH{1'b0}};",
      "    else if (iEN)",
      "      oData<={oData[WIDTH-2:0], iSI};",
      "  end",
      "",
      "endmodule"
    ],
    "description": "Shift register with serial in/out"
  },
  "FIFO": {
    "prefix": "fifo",
    "body": [
      "module fifo #(",
      "  parameter DATA_WIDTH = 8,",
      "  parameter DEPTH = 16",
      ")(",
      "  input wire iCLK,",
      "  input wire iRSTn,",
      "  input wire iWrEn,",
      "  input wire iRdEn,",
      "  input wire [DATA_WIDTH-1:0] iWrData,",
      "  output reg [DATA_WIDTH-1:0] oRdData,",
      "  output reg oFull,",
      "  output reg oEmpty",
      ");",
      "",
      "  reg [DATA_WIDTH-1:0] memory [0:DEPTH-1];",
      "  reg [$$clog2(DEPTH)-1:0] wr_ptr, rd_ptr;",
      "  reg [$$clog2(DEPTH):0] count;",
      "",
      "  always @(posedge iCLK or negedge iRSTn) begin",
      "    if (!iRSTn) begin",
      "      wr_ptr<=0;",
      "      rd_ptr<=0;",
      "      count<=0;",
      "      oFull<=0;",
      "      oEmpty<=1;",
      "    end else begin",
      "      // Write logic",
      "      if (iWrEn && !oFull) begin",
      "        memory[wr_ptr]<=iWrData;",
      "        wr_ptr<=wr_ptr + 1;",
      "      end",
      "      // Read logic",
      "      if (iRdEn && !oEmpty) begin",
      "        oRdData<=memory[rd_ptr];",
      "        rd_ptr<=rd_ptr + 1;",
      "      end",
      "      // Update count and flags",
      "      if (iWrEn && !oFull && !(iRdEn && !oEmpty))",
      "        count<=count + 1;",
      "      else if (iRdEn && !oEmpty && !(iWrEn && !oFull))",
      "        count<=count - 1;",
      "      ",
      "      oFull<=(count == DEPTH);",
      "      oEmpty<=(count == 0);",
      "    end",
      "  end",
      "",
      "endmodule"
    ],
    "description": "Synchronous FIFO buffer"
  },
  "FSM Template": {
    "prefix": "fsm",
    "body": [
      "// State definitions",
      "parameter IDLE = 2'd0,",
      "          STATE1 = 2'd1,",
      "          STATE2 = 2'd2,",
      "          STATE3 = 2'd3;",
      "",
      "reg [1:0] state, next_state;",
      "",
      "// State register",
      "always @(posedge ${1:iCLK} or negedge ${2:iRSTn}) begin",
      "  if (!${2:iRSTn})",
      "    state<=IDLE;",
      "  else",
      "    state<=next_state;",
      "end",
      "",
      "// Next state logic",
      "always @(*) begin",
      "  next_state = state;",
      "  case(state)",
      "    IDLE: begin",
      "      if (${3:condition})",
      "        next_state = STATE1;",
      "    end",
      "    STATE1: begin",
      "      next_state = STATE2;",
      "    end",
      "    STATE2: begin",
      "      next_state = STATE3;",
      "    end",
      "    STATE3: begin",
      "      next_state = IDLE;",
      "    end",
      "    default: next_state = IDLE;",
      "  endcase",
      "end",
      "",
      "// Output logic",
      "always @(*) begin",
      "  case(state)",
      "    IDLE: begin",
      "      $0",
      "    end",
      "    STATE1: begin",
      "      ",
      "    end",
      "    STATE2: begin",
      "      ",
      "    end",
      "    STATE3: begin",
      "      ",
      "    end",
      "  endcase",
      "end"
    ],
    "description": "Finite State Machine template"
  },
  "Module Template": {
    "prefix": "vmodule",
    "body": [
      "module ${1:module_name}(",
      "  input wire ${2:iCLK},",
      "  input wire ${3:iRSTn},",
      "  $0",
      ");",
      "",
      "  // Your code here",
      "",
      "endmodule"
    ],
    "description": "Basic Verilog module template"
  },
  "Testbench": {
    "prefix": "testbench",
    "body": [
      "`timescale 1ns / 1ps",
      "",
      "module tb_${1:module_name};",
      "",
      "  // Clock and reset",
      "  reg iCLK;",
      "  reg iRSTn;",
      "",
      "  // Test signals",
      "  $0",
      "",
      "  // Instantiate DUT",
      "  ${1:module_name} dut (",
      "    .iCLK(iCLK),",
      "    .iRSTn(iRSTn)",
      "  );",
      "",
      "  // Clock generation",
      "  initial begin",
      "    iCLK = 0;",
      "    forever #5 iCLK = ~iCLK;  // 100MHz clock",
      "  end",
      "",
      "  // Test sequence",
      "  initial begin",
      "    // Initialize",
      "    iRSTn = 0;",
      "    #100;",
      "    iRSTn = 1;",
      "    #100;",
      "    ",
      "    // Test cases",
      "    ",
      "    ",
      "    #1000;",
      "    $$finish;",
      "  end",
      "",
      "endmodule"
    ],
    "description": "Testbench template"
  },
  "Always Block - Combinational": {
    "prefix": "always_comb",
    "body": [
      "always @(*) begin",
      "  $0",
      "end"
    ],
    "description": "Combinational always block"
  },
  "Always Block - Sequential": {
    "prefix": "always_seq",
    "body": [
      "always @(posedge ${1:iCLK} or negedge ${2:iRSTn}) begin",
      "  if (!${2:iRSTn})",
      "    $0",
      "  else",
      "    ",
      "end"
    ],
    "description": "Sequential always block with async reset"
  },
  "Case Statement": {
    "prefix": "case",
    "body": [
      "case(${1:signal})",
      "  ${2:value1}: begin",
      "    $0",
      "  end",
      "  ${3:value2}: begin",
      "    ",
      "  end",
      "  default: begin",
      "    ",
      "  end",
      "endcase"
    ],
    "description": "Case statement template"
  },
  "For Loop": {
    "prefix": "for",
    "body": [
      "for (${1:i} = 0; ${1:i} < ${2:N}; ${1:i} = ${1:i} + 1) begin",
      "  $0",
      "end"
    ],
    "description": "For loop"
  },
  "Generate For": {
    "prefix": "genfor",
    "body": [
      "generate",
      "  genvar ${1:i};",
      "  for (${1:i} = 0; ${1:i} < ${2:N}; ${1:i} = ${1:i} + 1) begin : ${3:gen_block}",
      "    $0",
      "  end",
      "endgenerate"
    ],
    "description": "Generate for loop"
  },
  "Multiplexer 2-to-1": {
    "prefix": "mux2",
    "body": [
      "assign ${1:out} = ${2:sel} ? ${3:in1} : ${4:in0};"
    ],
    "description": "2-to-1 multiplexer"
  },
  "Multiplexer 4-to-1": {
    "prefix": "mux4",
    "body": [
      "always @(*) begin",
      "  case(${1:sel})",
      "    2'd0: ${2:out} = ${3:in0};",
      "    2'd1: ${2:out} = ${4:in1};",
      "    2'd2: ${2:out} = ${5:in2};",
      "    2'd3: ${2:out} = ${6:in3};",
      "    default: ${2:out} = ${3:in0};",
      "  endcase",
      "end"
    ],
    "description": "4-to-1 multiplexer"
  },
  "Encoder 4-to-2": {
    "prefix": "encoder",
    "body": [
      "always @(*) begin",
      "  case(${1:in})",
      "    4'b0001: ${2:out} = 2'd0;",
      "    4'b0010: ${2:out} = 2'd1;",
      "    4'b0100: ${2:out} = 2'd2;",
      "    4'b1000: ${2:out} = 2'd3;",
      "    default: ${2:out} = 2'd0;",
      "  endcase",
      "end"
    ],
    "description": "4-to-2 priority encoder"
  },
  "Decoder 2-to-4": {
    "prefix": "decoder",
    "body": [
      "always @(*) begin",
      "  ${1:out} = 4'b0000;",
      "  case(${2:in})",
      "    2'd0: ${1:out} = 4'b0001;",
      "    2'd1: ${1:out} = 4'b0010;",
      "    2'd2: ${1:out} = 4'b0100;",
      "    2'd3: ${1:out} = 4'b1000;",
      "  endcase",
      "end"
    ],
    "description": "2-to-4 decoder"
  },
  "Clock Divider": {
    "prefix": "clkdiv",
    "body": [
      "module clock_divider #(",
      "  parameter DIV_RATIO = ${1:100}",
      ")(",
      "  input wire iCLK,",
      "  input wire iRSTn,",
      "  output reg oCLK_DIV",
      ");",
      "",
      "  reg [31:0] counter;",
      "",
      "  always @(posedge iCLK or negedge iRSTn) begin",
      "    if (!iRSTn) begin",
      "      counter<=0;",
      "      oCLK_DIV<=0;",
      "    end else begin",
      "      if (counter >= DIV_RATIO/2 - 1) begin",
      "        counter<=0;",
      "        oCLK_DIV<=~oCLK_DIV;",
      "      end else begin",
      "        counter<=counter + 1;",
      "      end",
      "    end",
      "  end",
      "",
      "endmodule"
    ],
    "description": "Clock divider module"
  },
  "Edge Detector": {
    "prefix": "edge",
    "body": [
      "reg ${1:signal}_d;",
      "wire ${1:signal}_posedge = ${1:signal} & ~${1:signal}_d;",
      "wire ${1:signal}_negedge = ~${1:signal} & ${1:signal}_d;",
      "",
      "always @(posedge ${2:iCLK} or negedge ${3:iRSTn}) begin",
      "  if (!${3:iRSTn})",
      "    ${1:signal}_d<=1'b0;",
      "  else",
      "    ${1:signal}_d<=${1:signal};",
      "end"
    ],
    "description": "Rising/Falling edge detector"
  },
  "Synchronizer": {
    "prefix": "sync",
    "body": [
      "reg ${1:signal}_sync1, ${1:signal}_sync2;",
      "",
      "always @(posedge ${2:iCLK} or negedge ${3:iRSTn}) begin",
      "  if (!${3:iRSTn}) begin",
      "    ${1:signal}_sync1<=1'b0;",
      "    ${1:signal}_sync2<=1'b0;",
      "  end else begin",
      "    ${1:signal}_sync1<=${1:signal};",
      "    ${1:signal}_sync2<=${1:signal}_sync1;",
      "  end",
      "end"
    ],
    "description": "Two-stage synchronizer"
  },
  "PWM Generator": {
    "prefix": "pwm",
    "body": [
      "module pwm_generator #(",
      "  parameter WIDTH = 8",
      ")(",
      "  input wire iCLK,",
      "  input wire iRSTn,",
      "  input wire [WIDTH-1:0] iDuty,",
      "  output reg oPWM",
      ");",
      "",
      "  reg [WIDTH-1:0] counter;",
      "",
      "  always @(posedge iCLK or negedge iRSTn) begin",
      "    if (!iRSTn) begin",
      "      counter<=0;",
      "      oPWM<=0;",
      "    end else begin",
      "      counter<=counter + 1;",
      "      oPWM<=(counter < iDuty);",
      "    end",
      "  end",
      "",
      "endmodule"
    ],
    "description": "PWM signal generator"
  }
}